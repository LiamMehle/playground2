#include <iostream>

#include <vector>
#include <atomic>

#include <string>
#include <cstring>
#include <string_view>

#include <dirent.h>
#include <sys/types.h>

#include <cstdlib>

#include <future>
#include <mutex>

#define UID1(a, b) a##b              // concatenate
#define UID2(a, b) UID1(a, b)        // evaluate
#define UID UID2(___id, __COUNTER__) // add unique value to the end

struct file_data {
	std::string path;
	std::string_view name;
	unsigned int inode;
};

//unsigned int max_threads = std::thread::hardware_concurrency();
std::atomic<char> active_threads(0);

template<typename T>
class inc_dec {
private:
	T* const value_p;
public:
	inc_dec(T& value) : value_p(&value) {
		(*value_p)++;
	}
	~inc_dec() {
		(*value_p)--;
	}
};

std::vector<file_data> enum_recursive( const std::string path ) {
	inc_dec UID( active_threads ); // automatically managed variable
	std::vector<file_data>   ret;           // final return value
	std::vector<std::future<std::vector<file_data>>> recursive_future;
	DIR * const dir = opendir( path.c_str() );
	dirent* en_temp;
	if( dir == NULL )
		return std::vector<file_data>{};

	while( (en_temp = readdir( dir )) != NULL ) { // main loop

		if( strcmp( en_temp->d_name, ".") == 0 ||   // prevent re-opening same dir
		    strcmp( en_temp->d_name, "..") == 0 )   // prevent traversing up
			continue;

		const std::string new_path  = path + "/" + en_temp->d_name;
		const unsigned int name_len = strlen( en_temp->d_name );

		switch( en_temp->d_type ) {
			case DT_REG:
				ret.push_back({
					.path = std::move(new_path),
					.name = std::move(std::string_view( &(*new_path.cend())-name_len, name_len )),
					.inode = en_temp->d_ino
				});
				continue;

			case DT_DIR:
				/*auto launch_type = active_threads < max_threads ?
				                   std::launch::async :
				                   std::launch::deferred;*/
				try {
					recursive_future.push_back(std::async( std::launch::async,
					                          enum_recursive,
					                          std::string(new_path.c_str()))); // meed to pass copy
				} catch( ... ) {
					recursive_future.push_back(std::async( std::launch::deferred,
					                          enum_recursive,
					                          std::string(new_path.c_str()))); // meed to pass copy
				}
				continue;
		}
	}
	closedir( dir );
	for( auto& future : recursive_future ) {
		auto ret_recursive = future.get();
		ret.insert( ret.end(), ret_recursive.begin(), ret_recursive.end() );
	}
	return ret;
}

void print_usage() {
	std::cout << "stub\n";
}

int main( int argc, char** argv ) {

	if( argc != 2 && argc != 3 )
		print_usage();

//
//	if( argc == 3 ) {
//		max_threads = std::atoi(argv[2]);
//	} else {
//		max_threads = 99999;
//	}

	const std::string entry_path = [=](){
		std::string temp( 256, '\0');
		realpath(argv[1], temp.data() );
		temp.shrink_to_fit();
		return temp;
	}();
	const std::vector<file_data> files = enum_recursive( entry_path );

	/*for( auto& file : files ) {
		std::cout << "path: " << file.path << "\tino: " << file.inode << '\n';
	}*/
	return 0;
}
